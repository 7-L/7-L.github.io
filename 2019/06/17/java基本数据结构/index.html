<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="java,数据结构,">





  <link rel="alternate" href="/atom.xml" title="h7lyaphets" type="application/atom+xml">






<meta name="description" content="来源1搞不懂 HashMap？只因你缺一个 HashMap 的流程图！ 来源2HashMap？面试？我是谁？我在哪 来源3HashMap？面试？我是谁？我在哪    架构图   Collection接口中包含以下几种接口 list接口：内容允许重复。其中又包含三种数据结构，ArrayList、LindedList（实现了Queue接口），Vector。 Set接口：内容不允许重复。 Queue接">
<meta name="keywords" content="java,数据结构">
<meta property="og:type" content="article">
<meta property="og:title" content="java基本数据结构">
<meta property="og:url" content="http://yoursite.com/2019/06/17/java基本数据结构/index.html">
<meta property="og:site_name" content="h7lyaphets">
<meta property="og:description" content="来源1搞不懂 HashMap？只因你缺一个 HashMap 的流程图！ 来源2HashMap？面试？我是谁？我在哪 来源3HashMap？面试？我是谁？我在哪    架构图   Collection接口中包含以下几种接口 list接口：内容允许重复。其中又包含三种数据结构，ArrayList、LindedList（实现了Queue接口），Vector。 Set接口：内容不允许重复。 Queue接">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/06/17/java基本数据结构/all.png">
<meta property="og:image" content="http://yoursite.com/2019/06/17/java基本数据结构/all2.png">
<meta property="og:image" content="http://yoursite.com/2019/06/17/java基本数据结构/hashmapput.png">
<meta property="og:image" content="http://yoursite.com/2019/06/17/java基本数据结构/mapnode.png">
<meta property="og:image" content="http://yoursite.com/2019/06/17/java基本数据结构/mapbucket.png">
<meta property="og:image" content="http://yoursite.com/2019/06/17/java基本数据结构/hashcal.png">
<meta property="og:image" content="http://yoursite.com/2019/06/17/java基本数据结构/rbtree.png">
<meta property="og:updated_time" content="2019-06-23T02:45:04.412Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java基本数据结构">
<meta name="twitter:description" content="来源1搞不懂 HashMap？只因你缺一个 HashMap 的流程图！ 来源2HashMap？面试？我是谁？我在哪 来源3HashMap？面试？我是谁？我在哪    架构图   Collection接口中包含以下几种接口 list接口：内容允许重复。其中又包含三种数据结构，ArrayList、LindedList（实现了Queue接口），Vector。 Set接口：内容不允许重复。 Queue接">
<meta name="twitter:image" content="http://yoursite.com/2019/06/17/java基本数据结构/all.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/17/java基本数据结构/">





  <title>java基本数据结构 | h7lyaphets</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  
  
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband">
<a href="https://github.com/7-L" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">h7lyaphets</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习分享</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/java基本数据结构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java基本数据结构</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T14:50:50+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <ul>
<li>来源1<a href="https://mp.weixin.qq.com/s/5Uum_4B4n3QooRYKrLbZXg" target="_blank" rel="noopener">搞不懂 HashMap？只因你缺一个 HashMap 的流程图！</a></li>
<li>来源2<a href="http://www.importnew.com/31278.html" target="_blank" rel="noopener">HashMap？面试？我是谁？我在哪</a></li>
<li>来源3<a href="https://www.cnblogs.com/zhuoqingsen/p/HashMap.html" target="_blank" rel="noopener">HashMap？面试？我是谁？我在哪</a></li>
</ul>
<p><img src="/2019/06/17/java基本数据结构/all.png" alt="all"></p>
<ul>
<li>架构图</li>
</ul>
<p><img src="/2019/06/17/java基本数据结构/all2.png" alt="all"></p>
<h5 id="Collection接口中包含以下几种接口"><a href="#Collection接口中包含以下几种接口" class="headerlink" title="Collection接口中包含以下几种接口"></a>Collection接口中包含以下几种接口</h5><ol>
<li>list接口：内容允许重复。其中又包含三种数据结构，ArrayList、LindedList（实现了Queue接口），Vector。</li>
<li>Set接口：内容不允许重复。</li>
<li>Queue接口：队列接口。</li>
<li>sortedSet接口：单值排序接口。</li>
</ol>
<h5 id="Map接口中包含以下几种接口"><a href="#Map接口中包含以下几种接口" class="headerlink" title="Map接口中包含以下几种接口"></a>Map接口中包含以下几种接口</h5><ol>
<li>HashMap接口：无序存放，key不允许重复</li>
<li>HashTable接口：无序存放，key不允许重复</li>
<li>TreeMap接口：按key排序，key不重复</li>
<li>IdentityHashMap接口：key可重复</li>
<li>WeakHashMap接口：弱引用Map集合</li>
</ol>
<h5 id="详解HashMap"><a href="#详解HashMap" class="headerlink" title="详解HashMap"></a>详解HashMap</h5><p>面试的时候，HashMap 基本上是必问的知识点。<br><br>很多人在回答的时候，照本宣科。HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。<br><img src="/2019/06/17/java基本数据结构/hashmapput.png" alt="hashmapput"></p>
<p>简单的来说，可以用下面几句话总结！</p>
<p>①.判断键值对数组 table[i] 是否为空或为 null，否则执行 resize() 进行扩容；</p>
<p>②.根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，直接新建节点添加，转向⑥，如果 table[i] 不为空，转向③；</p>
<p>③.判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向④，这里的相同指的是 hashCode 以及 equals；</p>
<p>④.判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤.遍历 table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</p>
<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量 threshold，如果超过，进行扩容。</p>
<h6 id="为什么用HashMap"><a href="#为什么用HashMap" class="headerlink" title="为什么用HashMap"></a>为什么用HashMap</h6><ul>
<li>HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射</li>
<li>HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改</li>
<li>HashMap 是非 synchronized，所以 HashMap 很快</li>
<li>HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）</li>
</ul>
<h6 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h6><p>HashMap 是基于 hashing 的原理</p>
<p>我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。</p>
<p>这里关键点在于指出，HashMap 是在 bucket 中储存键对象和值对象，作为Map.Node 。</p>
<p><img src="/2019/06/17/java基本数据结构/mapnode.png" alt="mapnode"><br>以下是 HashMap 初始化</p>
<p>简化的模拟数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node[] table = <span class="keyword">new</span> Node[<span class="number">16</span>]; <span class="comment">// 散列桶初始化，table</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    hash; <span class="comment">//hash值</span></span><br><span class="line">    key; <span class="comment">//键</span></span><br><span class="line">    value; <span class="comment">//值</span></span><br><span class="line">    node next; <span class="comment">//用于指向链表的下一层（产生冲突，用拉链法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是具体的 put 过程（JDK1.8）</p>
<ol>
<li>对 Key 求 Hash 值，然后再计算下标</li>
<li>如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中）</li>
<li>如果碰撞了，以链表的方式链接到后面</li>
<li>如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表</li>
<li>如果节点已经存在就替换旧值</li>
<li>如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）</li>
</ol>
<p>以下是具体 get 过程</p>
<p><strong>考虑特殊情况</strong>：如果两个键的 hashcode 相同，你如何获取值对象？</p>
<p>当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。</p>
<p><img src="/2019/06/17/java基本数据结构/mapbucket.png" alt="mapbucket"></p>
<h6 id="减少碰撞的方法"><a href="#减少碰撞的方法" class="headerlink" title="减少碰撞的方法"></a>减少碰撞的方法</h6><ul>
<li>扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。）</li>
<li>使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。</li>
</ul>
<h6 id="HashMap中hash函数实现方法"><a href="#HashMap中hash函数实现方法" class="headerlink" title="HashMap中hash函数实现方法"></a>HashMap中hash函数实现方法</h6><p>我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看JDK1.8的源码是怎么做的（被楼主修饰了一下）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     h=key.hashCode()；返回散列值也就是hashcode</span><br><span class="line">      <span class="comment">// ^ ：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="comment">//其中n是数组的长度，即Map的数组部分初始化长度</span></span><br><span class="line">     <span class="keyword">return</span>  (n-<span class="number">1</span>)&amp;(h ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/17/java基本数据结构/hashcal.png" alt="hashcal"></p>
<p>简单来说就是</p>
<ol>
<li>高16bit不变，低16bit和高16bit做了一个异或(得到的HASHCODE转化为32位的二进制，前16位和后16位低16bit和高16bit做了一个异或)</li>
<li>(n-1)&amp;hash=-&gt;得到下标</li>
</ol>
<h6 id="拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"><a href="#拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？" class="headerlink" title="拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"></a>拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</h6><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，<strong>所以当长度大于8的时候</strong>，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p>
<h6 id="红黑树的理解"><a href="#红黑树的理解" class="headerlink" title="红黑树的理解"></a>红黑树的理解</h6><p><img src="/2019/06/17/java基本数据结构/rbtree.png" alt="rbtree"></p>
<ol>
<li>每个节点非红即黑</li>
<li>根节点总是黑色的</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li>
</ol>
<h6 id="解决hash碰撞还有哪些办法"><a href="#解决hash碰撞还有哪些办法" class="headerlink" title="解决hash碰撞还有哪些办法"></a>解决hash碰撞还有哪些办法</h6><p>开放定址法。</p>
<p>　　当冲突发生时，使用某种探查技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的地址。</p>
<p>　　按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。</p>
<p>　　下面给一个线性探查法的例子　　</p>
<p>　　问题：已知一组关键字为(26，36，41，38，44，15，68，12，06，51)，用除余法构造散列函数，用线性探查法解决冲突构造这组关键字的散列表。</p>
<p>　　解答：为了减少冲突，通常令装填因子α由除余法因子是13的散列函数计算出的上述关键字序列的散列地址为(0，10，2，12，5，2，3，12，6，12)。</p>
<p>　    前5个关键字插入时，其相应的地址均为开放地址，故将它们直接插入T[0]，T[10)，T[2]，T[12]和T[5]中。<br>　　当插入第6个关键字15时，其散列地址2(即h(15)=15％13=2)已被关键字41(15和41互为同义词)占用。故探查h1=(2+1)％13=3，此地址开放，所以将15放入T[3]中。<br>　   当插入第7个关键字68时，其散列地址3已被非同义词15先占用，故将其插入到T[4]中。<br>　   当插入第8个关键字12时，散列地址12已被同义词38占用，故探查hl=(12+1)％13=0，而T[0]亦被26占用，再探查h2=(12+2)％13=1，此地址开放，可将12插入其中。<br>　   类似地，第9个关键字06直接插入T[6]中；而最后一个关键字51插人时，因探查的地址12，0，1，…，6均非空，故51插入T[7]中。</p>
<h6 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h6><p>　　默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</p>
<h6 id="重新调整HashMap大小存在什么问题吗？"><a href="#重新调整HashMap大小存在什么问题吗？" class="headerlink" title="重新调整HashMap大小存在什么问题吗？"></a>重新调整HashMap大小存在什么问题吗？</h6><ul>
<li>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）</li>
<li>为什么多线程会导致死循环，它是怎么发生的？</li>
</ul>
<p>　　HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。</p>
<ol>
<li>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</li>
<li>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li>
</ol>
<hr>
<h5 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h5><ul>
<li>数组+链表方式存储</li>
<li>默认容量：11（质数 为宜）</li>
<li>put:<ul>
<li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li>
<li>若在链表中找到了，则替换旧值，若未找到则继续</li>
<li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li>
<li>将新元素加到链表头部</li>
</ul>
</li>
<li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。　　</li>
</ul>
<h6 id="HashMap和HashTable区别"><a href="#HashMap和HashTable区别" class="headerlink" title="HashMap和HashTable区别"></a>HashMap和HashTable区别</h6><ul>
<li>默认容量不同。扩容不同</li>
<li>线程安全，HT安全</li>
<li>效率不同，HT慢因为同步加锁原因</li>
</ul>
<h6 id="我们可以使用CocurrentHashMap来代替Hashtable吗？"><a href="#我们可以使用CocurrentHashMap来代替Hashtable吗？" class="headerlink" title="我们可以使用CocurrentHashMap来代替Hashtable吗？"></a>我们可以使用CocurrentHashMap来代替Hashtable吗？</h6><p>我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p>
<h6 id="CocurrentHashMap（1-7）"><a href="#CocurrentHashMap（1-7）" class="headerlink" title="CocurrentHashMap（1.7）"></a>CocurrentHashMap（1.7）</h6><ul>
<li>CocurrentHashMap是由Segment数组和HashEntry数组和链表组成</li>
<li>Segment是基于重入锁(ReentrantLock：一个数据段竞争锁，每个HashEntry一个链表结构的元素，利用Hash算法得到索引确定归属的数据段，也就是对应到在修改时需要竞争获取的锁。ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</li>
<li>核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性</li>
<li>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put操作如下。<ul>
<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>
<li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>最后会解除在 1 中所获取当前 Segment 的锁。</li>
</ul>
</li>
<li>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</li>
</ul>
<p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。</p>
<ul>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。最后解除当前 Segment 的锁</li>
</ul>
<h6 id="CocurrentHashMap（1-8）"><a href="#CocurrentHashMap（1-8）" class="headerlink" title="CocurrentHashMap（1.8）"></a>CocurrentHashMap（1.8）</h6><p>其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p>
<p>其中的 val next 都用了 volatile 修饰，保证了可见性</p>
<p>最大特点是引入了 CAS（借助 Unsafe 来实现【native code】）</p>
<p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<p>Unsafe 借助 CPU 指令 cmpxchg 来实现</p>
<p>使用实例：</p>
<p>对 sizeCtl 的控制都是用 CAS 来实现的</p>
<p>sizeCtl ：默认为0，用来控制 table 的初始化和扩容操作。</p>
<p>-1 代表table正在初始化</p>
<p>N 表示有 -N-1 个线程正在进行扩容操作</p>
<p>如果table未初始化，表示table需要初始化的大小。</p>
<p>如果table初始化完成，表示table的容量，默认是table大小的0.75倍，居然用这个公式算0.75（n - (n &gt;&gt;&gt; 2)）。</p>
<p>CAS 会出现的问题：ABA</p>
<p>解决：对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。</p>
<p>　　put过程</p>
<p>根据 key 计算出 hashcode 。</p>
<p>判断是否需要进行初始化。</p>
<p>通过 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p>
<p>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</p>
<p>如果都不满足，则利用 synchronized 锁写入数据。</p>
<p>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</p>
<p>　　get过程</p>
<p>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p>
<p>如果是红黑树那就按照树的方式获取值。</p>
<p>就不满足那就按照链表的方式遍历获取值。</p>
<h6 id="HashTable和HashMap区别"><a href="#HashTable和HashMap区别" class="headerlink" title="HashTable和HashMap区别"></a>HashTable和HashMap区别</h6><p>①继承不同。</p>
<p><code>public class Hashtable extends Dictionary implements Map</code><br><code>public class HashMap extends AbstractMap implements Map</code></p>
<p>②Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p>
<p>③Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p>
<p>④两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p>
<p>⑤哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p>
<p>⑥Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>
<p>Hash家族嘛,睾龟的很,高逼格,必须一次性两个值存储,就是所谓的键值对.<br>但是呢,Hash家族内部分为了几个小家族,分别是HashMap,Hashtable,TreeMap.<br>这几个家族呢,对键值对能不能存储null这种不是很安全的”买卖”有不一样的行动.<br>其中的HashMap家族与Hashtable、TreeMap不同,认为没有风险就没有利润!于是乎,准许自己的键值对都可以为null!<br>Hashtable与TreeMap一看SUN国王居然默许了HashMap的冒险行为,使得HashMap家族的利润大大增加,这两个家族也不甘寂寞,于是乎也就允许了自己的键值对可以为””,但是不能触碰null的界限.</p>
<p>关于HashMap的一些说法：<br>a)  HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。<br>b)  HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。<br>c)  HashMap实现不同步，线程不安全。  HashTable线程安全<br>d)  HashMap中的key-value都是存储在Entry中的。<br>e)  HashMap可以存null键和null值， 不保证元素的顺序恒久不变 ，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性<br>f)  解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。<br>注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；<br>   用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。<br>  拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。</p>

      
    </div>
    
    
    

    

    

    
    <div>

  
    <div>
    
        <div style="text-align:center;color: #ccc;font-size:14px;">-------------本文结束<i class="fa fa-paw"></i>感谢您的阅读-------------</div>
    
</div>

  
</div>
    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/java/" rel="tag"># java</a>
          
            <a href="/tags/数据结构/" rel="tag"># 数据结构</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/04/24/Spring-AOP实现原理/" rel="next" title="Spring AOP实现原理">
                <i class="fa fa-chevron-left"></i> Spring AOP实现原理
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/17/jvm-java虚拟机基础知识复习总结/" rel="prev" title="jvm-java虚拟机基础知识复习总结">
                jvm-java虚拟机基础知识复习总结 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">h7lyaphets</p>
              <p class="site-description motion-element" itemprop="description">postgraduate(2017-2020) | CS | java</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">29</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#Collection接口中包含以下几种接口"><span class="nav-number">1.</span> <span class="nav-text">Collection接口中包含以下几种接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Map接口中包含以下几种接口"><span class="nav-number">2.</span> <span class="nav-text">Map接口中包含以下几种接口</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#详解HashMap"><span class="nav-number">3.</span> <span class="nav-text">详解HashMap</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#为什么用HashMap"><span class="nav-number">3.1.</span> <span class="nav-text">为什么用HashMap</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#工作原理"><span class="nav-number">3.2.</span> <span class="nav-text">工作原理</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#减少碰撞的方法"><span class="nav-number">3.3.</span> <span class="nav-text">减少碰撞的方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HashMap中hash函数实现方法"><span class="nav-number">3.4.</span> <span class="nav-text">HashMap中hash函数实现方法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"><span class="nav-number">3.5.</span> <span class="nav-text">拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#红黑树的理解"><span class="nav-number">3.6.</span> <span class="nav-text">红黑树的理解</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#解决hash碰撞还有哪些办法"><span class="nav-number">3.7.</span> <span class="nav-text">解决hash碰撞还有哪些办法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><span class="nav-number">3.8.</span> <span class="nav-text">如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#重新调整HashMap大小存在什么问题吗？"><span class="nav-number">3.9.</span> <span class="nav-text">重新调整HashMap大小存在什么问题吗？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#HashTable"><span class="nav-number">4.</span> <span class="nav-text">HashTable</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#HashMap和HashTable区别"><span class="nav-number">4.1.</span> <span class="nav-text">HashMap和HashTable区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#我们可以使用CocurrentHashMap来代替Hashtable吗？"><span class="nav-number">4.2.</span> <span class="nav-text">我们可以使用CocurrentHashMap来代替Hashtable吗？</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CocurrentHashMap（1-7）"><span class="nav-number">4.3.</span> <span class="nav-text">CocurrentHashMap（1.7）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#CocurrentHashMap（1-8）"><span class="nav-number">4.4.</span> <span class="nav-text">CocurrentHashMap（1.8）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#HashTable和HashMap区别"><span class="nav-number">4.5.</span> <span class="nav-text">HashTable和HashMap区别</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">h7lyaphets</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
