<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="h7lyaphets" type="application/atom+xml">






<meta name="description" content="postgraduate(2017-2020) | CS | java">
<meta name="keywords" content="CS">
<meta property="og:type" content="website">
<meta property="og:title" content="h7lyaphets">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="h7lyaphets">
<meta property="og:description" content="postgraduate(2017-2020) | CS | java">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="h7lyaphets">
<meta name="twitter:description" content="postgraduate(2017-2020) | CS | java">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>h7lyaphets</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  
  
  
  <script type="text/javascript" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband">
<a href="https://github.com/7-L" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewbox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"/><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"/><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"/></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
    </div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">h7lyaphets</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">学习分享</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/16/about-mysql/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/16/about-mysql/" itemprop="url">about mysql</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-16T14:45:31+08:00">
                2019-08-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    
    <div>

  
</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/08/01/Map/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/01/Map/" itemprop="url">Map</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-01T17:08:03+08:00">
                2019-08-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://blog.csdn.net/yan245294305/article/details/88709760" target="_blank" rel="noopener">转载</a></p>
<p>Map，几乎是使用最广的一个数据结构了，他通过键值对应的方式存储数据。小到各种算法题，大到Redis数据库都是用这种存储方式。可以说，键值对应存储是存储格式发展的一个小趋势。因此掌握Java中各种Map也是必不可少的。</p>
<p>本文从面试提问的角度说一下各种Map的区别和应用场景。</p>
<hr>
<h3 id="Map的分类和存储方式"><a href="#Map的分类和存储方式" class="headerlink" title="Map的分类和存储方式"></a>Map的分类和存储方式</h3><p>如上文所说，Java中的Map是用来存储键值对的。Map在设计思想是通过把键值两个变量“装”到一个Entry中，然后通过一个数据结构来管理Entry。因此在Map的顶级父类中，有一个接口Entry用来描述键与值。每个具体的Map的实现类都实现Entry接口构建了自己的存储单元。例如Node内部类，它实现了Entry，具有了Entry接口规定的所有动作，并加入了存储的键值信息的变量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map类中的Entry接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="function">K <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function">V <span class="title">getValue</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function">V <span class="title">setValue</span><span class="params">(V value)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">       ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashMap中对Entry接口的具体实现</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Map插入键值对时键的值不允许有重复值，判定重复是根据equals方法来做的，因此当使用自定义类作为键值时要记住重写equals方法。</p>
<p>Map的分类可以按存储的介质（介质这个词更多的用在底层硬件，这里不知道用的恰当不恰当）来分。</p>
<p><strong>1.通过Hash表存储键值对：HashMap，HashTable，ConcurrentHashMap，LinkedHashMap</strong></p>
<p><strong>2.通过树结构存储键值对：TreeMap（红黑树）</strong></p>
<hr>
<h3 id="树结构的Map"><a href="#树结构的Map" class="headerlink" title="树结构的Map"></a>树结构的Map</h3><p>TreeMap通过红黑树存储Node（键值对）。红黑树本身就是一个二叉排序树，因此TreeMap具有给插入数据排序的功能。面试中问道此处一般就会开始问你红黑树了，红黑树在Java中应用的相当广泛，而且实现起来比较复杂，因此面试官不会让你手写的，但是一定要对红黑树的特性，红黑树删除节点，插入节点的逻辑了解，能描述。</p>
<p>TreeMap的排序是根据Comparable接口来实现的，插入的键需要实现该接口。而且可以自定义排序方式，通过构造函数传入Comparator指定排序方法。</p>
<hr>
<h3 id="Hash表结构的Map"><a href="#Hash表结构的Map" class="headerlink" title="Hash表结构的Map"></a>Hash表结构的Map</h3><p>重头戏开始了，基本面试只要问到Java基础十有八九就会问到HashTable，HashMap，ConcurrentHashMap。</p>
<p>LinkedHashMap呢？</p>
<p>LinkedHashMap是一种HashMap的特殊加强版，放到最后在讲它。</p>
<p>下面通过几个面试经典问题来介绍这三个兄弟般的Map。</p>
<h4 id="1-HashTable和HashMap的区别"><a href="#1-HashTable和HashMap的区别" class="headerlink" title="1.HashTable和HashMap的区别"></a>1.HashTable和HashMap的区别</h4><p>HashTable和HashMap的区别可以从线程安全性，执行效率，存储功能，继承体系四个方面说明。</p>
<p><strong>线程安全性：HashTable是线程安全的，HashMap是非线程安全的。</strong></p>
<p>这里我们可以打开源码查看一下。就会发现HashTable与HashMap的方法几乎一样。而且如果使用的早一点的JDK版本，这些方法的实现方法都基本一样，都是维护一个Hash表。但是HashTable的很多方法都在方法定义时加上了synchronized关键字确保线程安全。</p>
<p>因此如果程序内没有线程问题（单线程程序），HashMap是首选。如果多线程程序且需要保证线程安全性，就使用HashTable。</p>
<p>效率性：HashMap效率高，HashTable效率低。</p>
<p>HashTable中很多方法都用synchronize关键字修饰。synchronized是重量级锁，操作锁时伴随着线程的挂起和唤醒，这需要我们在用户态和内核态进行切换，因此效率很低。反观HashMap就好多了，没有线程安全保证，效率好很多。</p>
<p>而且在<strong>JDK8</strong>中的一大新特性就是对HashMap进行了加强。在之前的JDK版本中，HashMap在处理哈希碰撞时都是用链表解决。也就是所有Hash值一样的数据都保存在同一个链表中，这样当链表很长时检索就很吃力了，效率是O（n）。<strong>在JDK8中，如果链表中节点大于8就会把该链表转为红黑树存储</strong>，红黑树的查找效率是0（logn），效率更高。</p>
<p>但是当红黑树中的数据通过remove操作减少到小于6个时，又会变回链表结构。因为维护红黑树也是一个很麻烦的事情，当数据较少时，链表存储效率更好。</p>
<ul>
<li>存储功能：HashMap可以存储空值（null），HashTable不可以。</li>
</ul>
<p>这个不同点主要的原因发生在给键计算hash值的时候。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="comment">//如果传入的值是null，那么会返回0作为null的hash值</span></span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//HashTable 代码做了删减，保留了关键部分</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果值是null，抛出空指针异常</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       ....</span><br><span class="line">      <span class="comment">//键的hash码计算需要先调用它自身的hashCode方法，如果键是null，直接就报空指针错误了</span></span><br><span class="line">        <span class="keyword">int</span> hash = key.hashCode();</span><br><span class="line">       ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h5 id="继承体系：HashMap是Map继承体系中的一员，HashTable是单独的一个类，父类是Dictionary"><a href="#继承体系：HashMap是Map继承体系中的一员，HashTable是单独的一个类，父类是Dictionary" class="headerlink" title="继承体系：HashMap是Map继承体系中的一员，HashTable是单独的一个类，父类是Dictionary"></a>继承体系：HashMap是Map继承体系中的一员，HashTable是单独的一个类，父类是Dictionary</h5><p>Map继承体系是一个设计非常精巧复杂的结构体系，其中包含众多的抽象类和实现类。通过这个结构体系，设计人员满足了开发人员自定义Map，多态更换，功能加强等多个需求。</p>
<p>但是HashTable只有孤零零的一个类，不过它的年龄比整个Map体系都要大。</p>
<h4 id="2-知道ConcurrentHashMap吗？说说吧"><a href="#2-知道ConcurrentHashMap吗？说说吧" class="headerlink" title="2.知道ConcurrentHashMap吗？说说吧"></a>2.知道ConcurrentHashMap吗？说说吧</h4><p>ConcurrentHashMap是在JDK5随着并发包的上线一起推出的，设计目的是让它成为HashTable的替代品。这里可以把ConcurrentHashMap与HashMap和HashTable比较着说明。</p>
<p>众所周知，HashTable最大的缺点就是线程同步导致的效率低下。</p>
<p>首先，ConcurrentHashMap也是线程安全的，但并不是像HashTable那样通篇方法加synchronize关键字使用重量级锁实现线程安全。在底层容器的设计上，ConcurrentHashMap存储数据把哈希表分为多个部分，每个部分被称为Segment。当操作map时只锁定一个Segment即可，其他的Segment不用上锁，减小了锁的粒度，增大了并发性。</p>

          
        
      
    </div>
    
    
    

    

    

    
    <div>

  
</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/07/22/浏览器访问一次网站的全过程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/07/22/浏览器访问一次网站的全过程/" itemprop="url">浏览器访问一次网站的全过程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-07-22T10:24:49+08:00">
                2019-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><img src="/2019/07/22/浏览器访问一次网站的全过程/zong.png" alt="zong"></p>
<p><img src="/2019/07/22/浏览器访问一次网站的全过程/zong1.png" alt="zong1"></p>
<p>整个过程可以分为以下几个步骤：<br>在请求DNS解析之前应该还有一个，先去请求自己浏览器中的缓存，查看是否有对应的IP地址的缓存信息；</p>
<ul>
<li>其实整个查找过程应该是 浏览器缓存-&gt;系统缓存–路由器缓存—ISP DNS缓存（网络服务商（电信等）的DNS缓存）–递归搜索</li>
</ul>
<ol>
<li>浏览器发起DNS查询请求（域名解析服务器是基于UDP的，53端口）：浏览器作为客户端，当输入url时，浏览器中自动去请求DNS服务器，</li>
<li>经过域名解析之后获得相应的域名对应的IP；域名查询方式：根域名-&gt;顶级域名-&gt;次级域名-&gt;主机名。</li>
<li>客户端通过IP地址找到IP对应的服务器之后，要求建立TCP连接（三次握手）；</li>
<li>客户端发送HTTP请求，服务器接受HTTP请求并进行处理；<br>服务器收到请求之后，调用自身服务返回HTTP Response（响应包）；</li>
<li>浏览器解析HTTP响应，将内容显示出来：客户端收到响应包之后开始渲染该包内的body收到全部内容之后断开与服务器之间的TCP连接。（4次挥手）</li>
</ol>
<p>其中，第五个步骤，我们是这样的：浏览器收到响应内容时，生成一个主页框架，同时向服务端继续发送请求，这些请求主要是一些主页资源。（其中动态资源不缓存，静态资源要缓存）；另外，浏览器还要向服务器发送异步请求，有些页面显示完成之后客户端仍要与服务端保持联系。整个过程结束之后浏览器才断开TCP连接。</p>
<p>MVC</p>
<p>Model：应用程序中用于处理应用程序数据逻辑的部分；模型对象负责在数据库中存取数据；</p>
<p>View：应用程序中处理数据显示的部分；</p>
<p>Controller：应用程序中处理用户交互的部分。</p>

          
        
      
    </div>
    
    
    

    

    

    
    <div>

  
</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/24/Redis/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/24/Redis/" itemprop="url">Redis</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-24T18:00:44+08:00">
                2019-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Redis分布式锁如何续期"><a href="#Redis分布式锁如何续期" class="headerlink" title="Redis分布式锁如何续期"></a>Redis分布式锁如何续期</h2><ul>
<li><p><a href="https://juejin.im/post/5d122f516fb9a07ed911d08c#comment" target="_blank" rel="noopener">来源</a></p>
</li>
<li><p>问题<br><img src="/2019/06/24/Redis/temp.png" alt="question"></p>
</li>
<li><p>Redis分布式锁知识</p>
</li>
</ul>
<p>很多同学在用分布式锁时,都是直接百度搜索找一个<code>Redis</code>分布式锁工具类就直接用了.关键是该工具类中还充斥着很多<code>System.out.println();</code>等语句.其实<code>Redis</code>分布式锁比较正确的姿势是采用<code>redisson</code>这个客户端工具.具体介绍可以搜索最大的同性交友网站<code>github</code>.</p>
<h3 id="如何回答"><a href="#如何回答" class="headerlink" title="如何回答"></a>如何回答</h3><hr>
<p>首先如果你之前用Redis的分布式锁的姿势正确,并且看过相应的官方文档的话,这个问题So easy.我们来看</p>
<p><img src="/2019/06/24/Redis/rtLock.png" alt="rtLock"></p>
<p>坦白说,如果你英文棒棒哒那么看英文文档可能更好理解</p>
<blockquote>
<p>By default lock watchdog timeout is 30 seconds and can be changed through Config.lockWatchdogTimeout setting.</p>
</blockquote>
<p>但是如果看的是中文文档</p>
<blockquote>
<p>看门狗检查锁的超时时间默认是30秒</p>
</blockquote>
<p>这句话肥朝从语文角度分析就是一个歧义句,他有两个意思</p>
<blockquote>
<p>1.看门狗默认30秒去检查一次锁的超时时间</p>
</blockquote>
<blockquote>
<p>2.看们狗会去检查锁的超时时间,锁的时间时间默认是30秒</p>
</blockquote>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>我们根据官方文档给出的例子,写了一个最简单的demo,例子根据上面截图中Ctr+C和Ctr+V一波操作,如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class DemoMain &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);</span><br><span class="line"></span><br><span class="line">        RedissonClient redisson = Redisson.create(config);</span><br><span class="line">        RLock lock = redisson.getLock(&quot;anyLock&quot;);</span><br><span class="line"></span><br><span class="line">        lock.lock();</span><br><span class="line">        //lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><p><img src="/2019/06/24/Redis/create.png" alt="create"></p>
<p>从这里我们知道,internalLockLeaseTime 和 lockWatchdogTimeout这两个参数是相等的.<br>lockWatchdogTimeout默认值如下<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">long</span> lockWatchdogTimeout = <span class="number">30</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getLockWatchdogTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> lockWatchdogTimeout;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>复制代码从internalLockLeaseTime这个单词也可以看出,这个加的分布式锁的超时时间默认是30秒.但是还有一个问题,那就是这个看门狗,多久来延长一次有效期呢?我们往下看</p>
<h3 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h3><p><img src="/2019/06/24/Redis/lock.png" alt="lock"></p>
<p>从我图中框起来的地方我们就知道了,获取锁成功就会开启一个定时任务,也就是watchdog,定时任务会定期检查去续期renewExpirationAsync(threadId).<br>这里定时用的是netty-common包中的HashedWheelTimer,肥朝公众号已经和各大搜索引擎建立了密切的合作关系,你只需要把这个类在任何搜索引擎一搜,都能知道相关API参数的意义.<br>从图中我们明白,该定时调度每次调用的时间差是internalLockLeaseTime / 3.也就10秒.</p>
<h3 id="真相大白"><a href="#真相大白" class="headerlink" title="真相大白"></a>真相大白</h3><p>通过源码分析我们知道,默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 = 20秒的时候,就会进行一次续期,把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期,那自然30秒之后锁就解开了呗.</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>通过源码分析我们知道,默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 = 20秒的时候,就会进行一次续期,把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期,那自然30秒之后锁就解开了呗.</p>

          
        
      
    </div>
    
    
    

    

    

    
    <div>

  
</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/jvm-java虚拟机基础知识复习总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/jvm-java虚拟机基础知识复习总结/" itemprop="url">jvm-java虚拟机基础知识复习总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T18:29:24+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    
    <div>

  
</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/17/java基本数据结构/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/17/java基本数据结构/" itemprop="url">java基本数据结构</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-17T14:50:50+08:00">
                2019-06-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>来源1<a href="https://mp.weixin.qq.com/s/5Uum_4B4n3QooRYKrLbZXg" target="_blank" rel="noopener">搞不懂 HashMap？只因你缺一个 HashMap 的流程图！</a></li>
<li>来源2<a href="http://www.importnew.com/31278.html" target="_blank" rel="noopener">HashMap？面试？我是谁？我在哪</a></li>
<li>来源3<a href="https://www.cnblogs.com/zhuoqingsen/p/HashMap.html" target="_blank" rel="noopener">HashMap？面试？我是谁？我在哪</a></li>
</ul>
<p><img src="/2019/06/17/java基本数据结构/all.png" alt="all"></p>
<ul>
<li>架构图</li>
</ul>
<p><img src="/2019/06/17/java基本数据结构/all2.png" alt="all"></p>
<h5 id="Collection接口中包含以下几种接口"><a href="#Collection接口中包含以下几种接口" class="headerlink" title="Collection接口中包含以下几种接口"></a>Collection接口中包含以下几种接口</h5><ol>
<li>list接口：内容允许重复。其中又包含三种数据结构，ArrayList、LindedList（实现了Queue接口），Vector。</li>
<li>Set接口：内容不允许重复。</li>
<li>Queue接口：队列接口。</li>
<li>sortedSet接口：单值排序接口。</li>
</ol>
<h5 id="Map接口中包含以下几种接口"><a href="#Map接口中包含以下几种接口" class="headerlink" title="Map接口中包含以下几种接口"></a>Map接口中包含以下几种接口</h5><ol>
<li>HashMap接口：无序存放，key不允许重复</li>
<li>HashTable接口：无序存放，key不允许重复</li>
<li>TreeMap接口：按key排序，key不重复</li>
<li>IdentityHashMap接口：key可重复</li>
<li>WeakHashMap接口：弱引用Map集合</li>
</ol>
<h5 id="详解HashMap"><a href="#详解HashMap" class="headerlink" title="详解HashMap"></a>详解HashMap</h5><p>面试的时候，HashMap 基本上是必问的知识点。<br><br>很多人在回答的时候，照本宣科。HashMap 根据键的 hashCode 值存储数据，大多数情况下可以直接定位到它的值，因而具有很快的访问速度，但遍历顺序却是不确定的。HashMap 最多只允许一条记录的键为 null，允许多条记录的值为 null。HashMap 非线程安全，即任一时刻可以有多个线程同时写 HashMap，可能会导致数据的不一致。如果需要满足线程安全，可以用 Collections 的synchronizedMap 方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap。<br><img src="/2019/06/17/java基本数据结构/hashmapput.png" alt="hashmapput"></p>
<p>简单的来说，可以用下面几句话总结！</p>
<p>①.判断键值对数组 table[i] 是否为空或为 null，否则执行 resize() 进行扩容；</p>
<p>②.根据键值 key 计算 hash 值得到插入的数组索引 i，如果 table[i]==null，直接新建节点添加，转向⑥，如果 table[i] 不为空，转向③；</p>
<p>③.判断 table[i] 的首个元素是否和 key 一样，如果相同直接覆盖 value，否则转向④，这里的相同指的是 hashCode 以及 equals；</p>
<p>④.判断 table[i] 是否为 treeNode，即 table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值对，否则转向⑤；</p>
<p>⑤.遍历 table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操作，否则进行链表的插入操作；遍历过程中若发现 key 已经存在直接覆盖 value 即可；</p>
<p>⑥.插入成功后，判断实际存在的键值对数量size是否超多了最大容量 threshold，如果超过，进行扩容。</p>
<h6 id="为什么用HashMap"><a href="#为什么用HashMap" class="headerlink" title="为什么用HashMap"></a>为什么用HashMap</h6><ul>
<li>HashMap 是一个散列桶（数组和链表），它存储的内容是键值对 key-value 映射</li>
<li>HashMap 采用了数组和链表的数据结构，能在查询和修改方便继承了数组的线性查找和链表的寻址修改</li>
<li>HashMap 是非 synchronized，所以 HashMap 很快</li>
<li>HashMap 可以接受 null 键和值，而 Hashtable 则不能（原因就是 equlas() 方法需要对象，因为 HashMap 是后出的 API 经过处理才可以）</li>
</ul>
<h6 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h6><p>HashMap 是基于 hashing 的原理</p>
<p>我们使用 put(key, value) 存储对象到 HashMap 中，使用 get(key) 从 HashMap 中获取对象。当我们给 put() 方法传递键和值时，我们先对键调用 hashCode() 方法，计算并返回的 hashCode 是用于找到 Map 数组的 bucket 位置来储存 Node 对象。</p>
<p>这里关键点在于指出，HashMap 是在 bucket 中储存键对象和值对象，作为Map.Node 。</p>
<p><img src="/2019/06/17/java基本数据结构/mapnode.png" alt="mapnode"><br>以下是 HashMap 初始化</p>
<p>简化的模拟数据结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Node[] table = <span class="keyword">new</span> Node[<span class="number">16</span>]; <span class="comment">// 散列桶初始化，table</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line">    hash; <span class="comment">//hash值</span></span><br><span class="line">    key; <span class="comment">//键</span></span><br><span class="line">    value; <span class="comment">//值</span></span><br><span class="line">    node next; <span class="comment">//用于指向链表的下一层（产生冲突，用拉链法）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下是具体的 put 过程（JDK1.8）</p>
<ol>
<li>对 Key 求 Hash 值，然后再计算下标</li>
<li>如果没有碰撞，直接放入桶中（碰撞的意思是计算得到的 Hash 值相同，需要放到同一个 bucket 中）</li>
<li>如果碰撞了，以链表的方式链接到后面</li>
<li>如果链表长度超过阀值（TREEIFY THRESHOLD==8），就把链表转成红黑树，链表长度低于6，就把红黑树转回链表</li>
<li>如果节点已经存在就替换旧值</li>
<li>如果桶满了（容量16*加载因子0.75），就需要 resize（扩容2倍后重排）</li>
</ol>
<p>以下是具体 get 过程</p>
<p><strong>考虑特殊情况</strong>：如果两个键的 hashcode 相同，你如何获取值对象？</p>
<p>当我们调用 get() 方法，HashMap 会使用键对象的 hashcode 找到 bucket 位置，找到 bucket 位置之后，会调用 keys.equals() 方法去找到链表中正确的节点，最终找到要找的值对象。</p>
<p><img src="/2019/06/17/java基本数据结构/mapbucket.png" alt="mapbucket"></p>
<h6 id="减少碰撞的方法"><a href="#减少碰撞的方法" class="headerlink" title="减少碰撞的方法"></a>减少碰撞的方法</h6><ul>
<li>扰动函数可以减少碰撞，原理是如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这就意味着存链表结构减小，这样取值的话就不会频繁调用equal方法，这样就能提高HashMap的性能。（扰动即Hash方法内部的算法实现，目的是让不同对象返回不同hashcode。）</li>
<li>使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择。为什么String, Interger这样的wrapper类适合作为键？因为String是final的，而且已经重写了equals()和hashCode()方法了。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。</li>
</ul>
<h6 id="HashMap中hash函数实现方法"><a href="#HashMap中hash函数实现方法" class="headerlink" title="HashMap中hash函数实现方法"></a>HashMap中hash函数实现方法</h6><p>我们可以看到在hashmap中要找到某个元素，需要根据key的hash值来求得对应数组中的位置。如何计算这个位置就是hash算法。前面说过hashmap的数据结构是数组和链表的结合，所以我们当然希望这个hashmap里面的元素位置尽量的分布均匀些，尽量使得每个位置上的元素数量只有一个，那么当我们用hash算法求得这个位置的时候，马上就可以知道对应位置的元素就是我们要的，而不用再去遍历链表。 所以我们首先想到的就是把hashcode对数组长度取模运算，这样一来，元素的分布相对来说是比较均匀的。但是，“模”运算的消耗还是比较大的，能不能找一种更快速，消耗更小的方式，我们来看看JDK1.8的源码是怎么做的（被楼主修饰了一下）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="keyword">int</span> h;</span><br><span class="line">     h=key.hashCode()；返回散列值也就是hashcode</span><br><span class="line">      <span class="comment">// ^ ：按位异或</span></span><br><span class="line">      <span class="comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span></span><br><span class="line">      <span class="comment">//其中n是数组的长度，即Map的数组部分初始化长度</span></span><br><span class="line">     <span class="keyword">return</span>  (n-<span class="number">1</span>)&amp;(h ^ (h &gt;&gt;&gt; <span class="number">16</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/2019/06/17/java基本数据结构/hashcal.png" alt="hashcal"></p>
<p>简单来说就是</p>
<ol>
<li>高16bit不变，低16bit和高16bit做了一个异或(得到的HASHCODE转化为32位的二进制，前16位和后16位低16bit和高16bit做了一个异或)</li>
<li>(n-1)&amp;hash=-&gt;得到下标</li>
</ol>
<h6 id="拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"><a href="#拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？" class="headerlink" title="拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？"></a>拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？</h6><p>之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，<strong>所以当长度大于8的时候</strong>，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。</p>
<h6 id="红黑树的理解"><a href="#红黑树的理解" class="headerlink" title="红黑树的理解"></a>红黑树的理解</h6><p><img src="/2019/06/17/java基本数据结构/rbtree.png" alt="rbtree"></p>
<ol>
<li>每个节点非红即黑</li>
<li>根节点总是黑色的</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）</li>
<li>每个叶子节点都是黑色的空节点（NIL节点）</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）</li>
</ol>
<h6 id="解决hash碰撞还有哪些办法"><a href="#解决hash碰撞还有哪些办法" class="headerlink" title="解决hash碰撞还有哪些办法"></a>解决hash碰撞还有哪些办法</h6><p>开放定址法。</p>
<p>　　当冲突发生时，使用某种探查技术在散列表中形成一个探查(测)序列。沿此序列逐个单元地查找，直到找到给定的地址。</p>
<p>　　按照形成探查序列的方法不同，可将开放定址法区分为线性探查法、二次探查法、双重散列法等。</p>
<p>　　下面给一个线性探查法的例子　　</p>
<p>　　问题：已知一组关键字为(26，36，41，38，44，15，68，12，06，51)，用除余法构造散列函数，用线性探查法解决冲突构造这组关键字的散列表。</p>
<p>　　解答：为了减少冲突，通常令装填因子α由除余法因子是13的散列函数计算出的上述关键字序列的散列地址为(0，10，2，12，5，2，3，12，6，12)。</p>
<p>　    前5个关键字插入时，其相应的地址均为开放地址，故将它们直接插入T[0]，T[10)，T[2]，T[12]和T[5]中。<br>　　当插入第6个关键字15时，其散列地址2(即h(15)=15％13=2)已被关键字41(15和41互为同义词)占用。故探查h1=(2+1)％13=3，此地址开放，所以将15放入T[3]中。<br>　   当插入第7个关键字68时，其散列地址3已被非同义词15先占用，故将其插入到T[4]中。<br>　   当插入第8个关键字12时，散列地址12已被同义词38占用，故探查hl=(12+1)％13=0，而T[0]亦被26占用，再探查h2=(12+2)％13=1，此地址开放，可将12插入其中。<br>　   类似地，第9个关键字06直接插入T[6]中；而最后一个关键字51插人时，因探查的地址12，0，1，…，6均非空，故51插入T[7]中。</p>
<h6 id="如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？"><a href="#如果HashMap的大小超过了负载因子-load-factor-定义的容量，怎么办？" class="headerlink" title="如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？"></a>如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</h6><p>　　默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置。这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为&lt;原下标+原容量&gt;的位置</p>
<h6 id="重新调整HashMap大小存在什么问题吗？"><a href="#重新调整HashMap大小存在什么问题吗？" class="headerlink" title="重新调整HashMap大小存在什么问题吗？"></a>重新调整HashMap大小存在什么问题吗？</h6><ul>
<li>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。(多线程的环境下不使用HashMap）</li>
<li>为什么多线程会导致死循环，它是怎么发生的？</li>
</ul>
<p>　　HashMap的容量是有限的。当经过多次元素插入，使得HashMap达到一定饱和度时，Key映射位置发生冲突的几率会逐渐提高。这时候，HashMap需要扩展它的长度，也就是进行Resize。</p>
<ol>
<li>扩容：创建一个新的Entry空数组，长度是原数组的2倍。</li>
<li>ReHash：遍历原Entry数组，把所有的Entry重新Hash到新数组。</li>
</ol>
<hr>
<h5 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h5><ul>
<li>数组+链表方式存储</li>
<li>默认容量：11（质数 为宜）</li>
<li>put:<ul>
<li>索引计算 : （key.hashCode() &amp; 0x7FFFFFFF）% table.length</li>
<li>若在链表中找到了，则替换旧值，若未找到则继续</li>
<li>当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。</li>
<li>将新元素加到链表头部</li>
</ul>
</li>
<li>对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。　　</li>
</ul>
<h6 id="HashMap和HashTable区别"><a href="#HashMap和HashTable区别" class="headerlink" title="HashMap和HashTable区别"></a>HashMap和HashTable区别</h6><ul>
<li>默认容量不同。扩容不同</li>
<li>线程安全，HT安全</li>
<li>效率不同，HT慢因为同步加锁原因</li>
</ul>
<h6 id="我们可以使用CocurrentHashMap来代替Hashtable吗？"><a href="#我们可以使用CocurrentHashMap来代替Hashtable吗？" class="headerlink" title="我们可以使用CocurrentHashMap来代替Hashtable吗？"></a>我们可以使用CocurrentHashMap来代替Hashtable吗？</h6><p>我们知道Hashtable是synchronized的，但是ConcurrentHashMap同步性能更好，因为它仅仅根据同步级别对map的一部分进行上锁。ConcurrentHashMap当然可以代替HashTable，但是HashTable提供更强的线程安全性。它们都可以用于多线程的环境，但是当Hashtable的大小增加到一定的时候，性能会急剧下降，因为迭代时需要被锁定很长的时间。因为ConcurrentHashMap引入了分割(segmentation)，不论它变得多么大，仅仅需要锁定map的某个部分，而其它的线程不需要等到迭代完成才能访问map。简而言之，在迭代的过程中，ConcurrentHashMap仅仅锁定map的某个部分，而Hashtable则会锁定整个map。</p>
<h6 id="CocurrentHashMap（1-7）"><a href="#CocurrentHashMap（1-7）" class="headerlink" title="CocurrentHashMap（1.7）"></a>CocurrentHashMap（1.7）</h6><ul>
<li>CocurrentHashMap是由Segment数组和HashEntry数组和链表组成</li>
<li>Segment是基于重入锁(ReentrantLock：一个数据段竞争锁，每个HashEntry一个链表结构的元素，利用Hash算法得到索引确定归属的数据段，也就是对应到在修改时需要竞争获取的锁。ConcurrentHashMap 支持 CurrencyLevel (Segment 数组数量)的线程并发。每当一个线程占用锁访问一个 Segment 时，不会影响到其他的 Segment。</li>
<li>核心数据如 value ，以及链表都是 volatile 修饰的，保证了获取时的可见性</li>
<li>首先是通过 key 定位到 Segment，之后在对应的 Segment 中进行具体的 put操作如下。<ul>
<li>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</li>
<li>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。</li>
<li>不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</li>
<li>最后会解除在 1 中所获取当前 Segment 的锁。</li>
</ul>
</li>
<li>虽然 HashEntry 中的 value 是用 volatile 关键词修饰的，但是并不能保证并发的原子性，所以 put 操作时仍然需要加锁处理。</li>
</ul>
<p>首先第一步的时候会尝试获取锁，如果获取失败肯定就有其他线程存在竞争，则利用 scanAndLockForPut() 自旋获取锁。</p>
<ul>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。最后解除当前 Segment 的锁</li>
</ul>
<h6 id="CocurrentHashMap（1-8）"><a href="#CocurrentHashMap（1-8）" class="headerlink" title="CocurrentHashMap（1.8）"></a>CocurrentHashMap（1.8）</h6><p>其中抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性。</p>
<p>其中的 val next 都用了 volatile 修饰，保证了可见性</p>
<p>最大特点是引入了 CAS（借助 Unsafe 来实现【native code】）</p>
<p>CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。</p>
<p>Unsafe 借助 CPU 指令 cmpxchg 来实现</p>
<p>使用实例：</p>
<p>对 sizeCtl 的控制都是用 CAS 来实现的</p>
<p>sizeCtl ：默认为0，用来控制 table 的初始化和扩容操作。</p>
<p>-1 代表table正在初始化</p>
<p>N 表示有 -N-1 个线程正在进行扩容操作</p>
<p>如果table未初始化，表示table需要初始化的大小。</p>
<p>如果table初始化完成，表示table的容量，默认是table大小的0.75倍，居然用这个公式算0.75（n - (n &gt;&gt;&gt; 2)）。</p>
<p>CAS 会出现的问题：ABA</p>
<p>解决：对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。</p>
<p>　　put过程</p>
<p>根据 key 计算出 hashcode 。</p>
<p>判断是否需要进行初始化。</p>
<p>通过 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</p>
<p>如果当前位置的 hashcode == MOVED == -1,则需要进行扩容。</p>
<p>如果都不满足，则利用 synchronized 锁写入数据。</p>
<p>如果数量大于 TREEIFY_THRESHOLD 则要转换为红黑树。</p>
<p>　　get过程</p>
<p>根据计算出来的 hashcode 寻址，如果就在桶上那么直接返回值。</p>
<p>如果是红黑树那就按照树的方式获取值。</p>
<p>就不满足那就按照链表的方式遍历获取值。</p>
<h6 id="HashTable和HashMap区别"><a href="#HashTable和HashMap区别" class="headerlink" title="HashTable和HashMap区别"></a>HashTable和HashMap区别</h6><p>①继承不同。</p>
<p><code>public class Hashtable extends Dictionary implements Map</code><br><code>public class HashMap extends AbstractMap implements Map</code></p>
<p>②Hashtable 中的方法是同步的，而HashMap中的方法在缺省情况下是非同步的。在多线程并发的环境下，可以直接使用Hashtable，但是要使用HashMap的话就要自己增加同步处理了。</p>
<p>③Hashtable中，key和value都不允许出现null值。在HashMap中，null可以作为键，这样的键只有一个；可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示 HashMap中没有该键，也可以表示该键所对应的值为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个键， 而应该用containsKey()方法来判断。</p>
<p>④两个遍历方式的内部实现上不同。Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。</p>
<p>⑤哈希值的使用不同，HashTable直接使用对象的hashCode。而HashMap重新计算hash值。</p>
<p>⑥Hashtable和HashMap它们两个内部实现方式的数组的初始大小和扩容的方式。HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</p>
<p>Hash家族嘛,睾龟的很,高逼格,必须一次性两个值存储,就是所谓的键值对.<br>但是呢,Hash家族内部分为了几个小家族,分别是HashMap,Hashtable,TreeMap.<br>这几个家族呢,对键值对能不能存储null这种不是很安全的”买卖”有不一样的行动.<br>其中的HashMap家族与Hashtable、TreeMap不同,认为没有风险就没有利润!于是乎,准许自己的键值对都可以为null!<br>Hashtable与TreeMap一看SUN国王居然默许了HashMap的冒险行为,使得HashMap家族的利润大大增加,这两个家族也不甘寂寞,于是乎也就允许了自己的键值对可以为””,但是不能触碰null的界限.</p>
<p>关于HashMap的一些说法：<br>a)  HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。<br>b)  HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子。<br>c)  HashMap实现不同步，线程不安全。  HashTable线程安全<br>d)  HashMap中的key-value都是存储在Entry中的。<br>e)  HashMap可以存null键和null值， 不保证元素的顺序恒久不变 ，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性<br>f)  解决冲突主要有三种方法：定址法，拉链法，再散列法。HashMap是采用拉链法解决哈希冲突的。<br>注： 链表法是将相同hash值的对象组成一个链表放在hash值对应的槽位；<br>   用开放定址法解决冲突的做法是：当冲突发生时，使用某种探查(亦称探测)技术在散列表中形成一个探查(测)序列。 沿此序列逐个单元地查找，直到找到给定 的关键字，或者碰到一个开放的地址(即该地址单元为空)为止（若要插入，在探查到开放的地址，则可将待插入的新结点存人该地址单元）。<br>  拉链法解决冲突的做法是： 将所有关键字为同义词的结点链接在同一个单链表中 。若选定的散列表长度为m，则可将散列表定义为一个由m个头指针组成的指针数 组T[0..m-1]。凡是散列地址为i的结点，均插入到以T[i]为头指针的单链表中。T中各分量的初值均应为空指针。在拉链法中，装填因子α可以大于1，但一般均取α≤1。拉链法适合未规定元素的大小。</p>
<h6 id="HashMap中equal-和hashcode-关系"><a href="#HashMap中equal-和hashcode-关系" class="headerlink" title="HashMap中equal()和hashcode()关系"></a>HashMap中equal()和hashcode()关系</h6><p>  hashCode()方法和equals()方法的作用其实是一样的，在Java里都是用来对比两个对象是否相等一致。</p>
<p>那么equals()既然已经能实现对比的功能了，为什么还要hashCode()呢？因为重写的equals()里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高。</p>
<p>那么hashCode()既然效率这么高为什么还要equals()呢？ 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，</p>
<p>所以我们可以得出：</p>
<ol>
<li><p>equals()相等的两个对象他们的hashCode()肯定相等，也就是用equals()对比是绝对可靠的。</p>
</li>
<li><p>hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。</p>
</li>
</ol>
<p>所有对于需要大量并且快速的对比的话如果都用equals()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equals()，如果equals()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性！</p>

          
        
      
    </div>
    
    
    

    

    

    
    <div>

  
</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/24/Spring-AOP实现原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/24/Spring-AOP实现原理/" itemprop="url">Spring AOP实现原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-24T19:36:00+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h2><p>AOP（Aspect-OrientedProgramming，面向方面编程），可以说是OOP（Object-Oriented Programing，面向对象编程）的补充和完善。OOP引入封装、继承和多态性等概念来建立一种对象层次结构，用以模拟公共行为的一个集合。当我们需要为分散的对象引入公共行为的时候，OOP则显得无能为力。也就是说，OOP允许你定义从上到下的关系，但并不适合定义从左到右的关系。例如日志功能。日志代码往往水平地散布在所有对象层次中，而与它所散布到的对象的核心功能毫无关系。对于其他类型的代码，如安全性、异常处理和透明的持续性也是如此。这种散布在各处的无关的代码被称为横切（cross-cutting）代码，在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>而AOP技术则恰恰相反，它利用一种称为“横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其名为“Aspect”，即方面。所谓“方面”，简单地说，就是将那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可操作性和可维护性。AOP代表的是一个横向的关系，如果说“对象”是一个空心的圆柱体，其中封装的是对象的属性和行为；那么面向方面编程的方法，就仿佛一把利刃，将这些空心圆柱体剖开，以获得其内部的消息。而剖开的切面，也就是所谓的“方面”了。然后它又以巧夺天功的妙手将这些剖开的切面复原，不留痕迹。</p>
<p>使用“横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处都基本相似。比如权限认证、日志、事务处理。Aop 的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。正如Avanade公司的高级方案构架师Adam Magee所说，AOP的核心思想就是“将应用程序中的商业逻辑同对其提供支持的通用服务进行分离。”</p>
<p>实现AOP的技术，主要分为两大类：一是采用动态代理技术，利用截取消息的方式，对该消息进行装饰，以取代原有对象行为的执行；二是采用静态织入的方式，引入特定的语法创建“方面”，从而使得编译器可以在编译期间织入有关“方面”的代码。</p>
<h2 id="AOP使用场景"><a href="#AOP使用场景" class="headerlink" title="AOP使用场景"></a>AOP使用场景</h2><p>AOP用来封装横切关注点，具体可以在下面的场景中使用:</p>
<p>Authentication 权限</p>
<p>Caching 缓存</p>
<p>Context passing 内容传递</p>
<p>Error handling 错误处理</p>
<p>Lazy loading　懒加载</p>
<p>Debugging　　调试</p>
<p>logging, tracing, profiling and monitoring　记录跟踪　优化　校准</p>
<p>Performance optimization　性能优化</p>
<p>Persistence　　持久化</p>
<p>Resource pooling　资源池</p>
<p>Synchronization　同步</p>
<p>Transactions 事务</p>
<h2 id="AOP相关概念"><a href="#AOP相关概念" class="headerlink" title="AOP相关概念"></a>AOP相关概念</h2><p>方面（Aspect）：一个关注点的模块化，这个关注点实现可能另外横切多个对象。事务管理是J2EE应用中一个很好的横切关注点例子。方面用Spring的 Advisor或拦截器实现。</p>
<p>连接点（Joinpoint）: 程序执行过程中明确的点，如方法的调用或特定的异常被抛出。</p>
<p>通知（Advice）: 在特定的连接点，AOP框架执行的动作。各种类型的通知包括“around”、“before”和“throws”通知。通知类型将在下面讨论。许多AOP框架包括Spring都是以拦截器做通知模型，维护一个“围绕”连接点的拦截器链。Spring中定义了四个advice: BeforeAdvice, AfterAdvice, ThrowAdvice和DynamicIntroductionAdvice</p>
<p>切入点（Pointcut）: 指定一个通知将被引发的一系列连接点的集合。AOP框架必须允许开发者指定切入点：例如，使用正则表达式。 Spring定义了Pointcut接口，用来组合MethodMatcher和ClassFilter，可以通过名字很清楚的理解， MethodMatcher是用来检查目标类的方法是否可以被应用此通知，而ClassFilter是用来检查Pointcut是否应该应用到目标类上</p>
<p>引入（Introduction）: 添加方法或字段到被通知的类。 Spring允许引入新的接口到任何被通知的对象。例如，你可以使用一个引入使任何对象实现 IsModified接口，来简化缓存。Spring中要使用Introduction, 可有通过DelegatingIntroductionInterceptor来实现通知，通过DefaultIntroductionAdvisor来配置Advice和代理类要实现的接口</p>
<p>目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO</p>
<p>AOP代理（AOP Proxy）: AOP框架创建的对象，包含通知。 在Spring中，AOP代理可以是JDK动态代理或者CGLIB代理。</p>
<p>织入（Weaving）: 组装方面来创建一个被通知对象。这可以在编译时完成（例如使用AspectJ编译器），也可以在运行时完成。Spring和其他纯Java AOP框架一样，在运行时完成织入。</p>
<h2 id="如何使用Spring-AOP"><a href="#如何使用Spring-AOP" class="headerlink" title="如何使用Spring AOP"></a>如何使用Spring AOP</h2><p>可以通过配置文件或者编程的方式来使用Spring AOP。</p>
<p>配置可以通过xml文件来进行，大概有四种方式：</p>
<ol>
<li><p>配置ProxyFactoryBean，显式地设置advisors, advice, target等</p>
</li>
<li><p>配置AutoProxyCreator，这种方式下，还是如以前一样使用定义的bean，但是从容器中获得的其实已经是代理对象</p>
</li>
<li><p>通过<a href="aop:config" target="_blank" rel="noopener">aop:config</a>来配置</p>
</li>
<li><p>通过&lt;aop: aspectj-autoproxy&gt;来配置，使用AspectJ的注解来标识通知及切入点</p>
</li>
</ol>
<p>也可以直接使用ProxyFactory来以编程的方式使用Spring AOP，通过ProxyFactory提供的方法可以设置target对象, advisor等相关配置，最终通过 getProxy()方法来获取代理对象</p>
<p>具体使用的示例可以google. 这里略去</p>
<h2 id="Spring-AOP代理对象的生成"><a href="#Spring-AOP代理对象的生成" class="headerlink" title="Spring AOP代理对象的生成"></a>Spring AOP代理对象的生成</h2><p>Spring提供了两种方式来生成代理对象: JDKProxy和Cglib，具体使用哪种方式生成由AopProxyFactory根据AdvisedSupport对象的配置来决定。默认的策略是如果目标类是接口，则使用JDK动态代理技术，否则使用Cglib来生成代理。下面我们来研究一下Spring如何使用JDK来生成代理对象，具体的生成代码放在JdkDynamicAopProxy这个类中，直接上相关代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    
    <div>

  
</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/13/windows进程占用高svchost/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/13/windows进程占用高svchost/" itemprop="url">windows进程占用高svchost</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-13T14:27:52+08:00">
                2019-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h6 id="今天中午莫名其妙电脑风扇高转，我猜可能是什么进程导致了CPU占用过高。结果一看，看到两个进程几乎占满了CPU，Local-Session-Manager有两项。然后查看其中pid，通过命令tasklist-svc找到对应两个服务其中一个为LSM和TermService-然后网上查到是关于远程桌面相关。后来突然想到上午安装了tv-14版本，可能是之前卸载上一个版本，某个进程没有关掉，导致Windows这两个进程一直在寻找，最终重启了tv，成功降低了占用。"><a href="#今天中午莫名其妙电脑风扇高转，我猜可能是什么进程导致了CPU占用过高。结果一看，看到两个进程几乎占满了CPU，Local-Session-Manager有两项。然后查看其中pid，通过命令tasklist-svc找到对应两个服务其中一个为LSM和TermService-然后网上查到是关于远程桌面相关。后来突然想到上午安装了tv-14版本，可能是之前卸载上一个版本，某个进程没有关掉，导致Windows这两个进程一直在寻找，最终重启了tv，成功降低了占用。" class="headerlink" title="今天中午莫名其妙电脑风扇高转，我猜可能是什么进程导致了CPU占用过高。结果一看，看到两个进程几乎占满了CPU，Local Session Manager有两项。然后查看其中pid，通过命令tasklist /svc找到对应两个服务其中一个为LSM和TermService,然后网上查到是关于远程桌面相关。后来突然想到上午安装了tv 14版本，可能是之前卸载上一个版本，某个进程没有关掉，导致Windows这两个进程一直在寻找，最终重启了tv，成功降低了占用。"></a>今天中午莫名其妙电脑风扇高转，我猜可能是什么进程导致了CPU占用过高。结果一看，看到两个进程几乎占满了CPU，Local Session Manager有两项。然后查看其中pid，通过命令<code>tasklist /svc</code>找到对应两个服务其中一个为<code>LSM</code>和<code>TermService</code>,然后网上查到是关于远程桌面相关。后来突然想到上午安装了tv 14版本，可能是之前卸载上一个版本，某个进程没有关掉，导致Windows这两个进程一直在寻找，最终重启了tv，成功降低了占用。</h6>
          
        
      
    </div>
    
    
    

    

    

    
    <div>

  
</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/02/atom快捷键/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/02/atom快捷键/" itemprop="url">atom快捷键</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-02T10:09:25+08:00">
                2019-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ul>
<li>使用atom作为编辑器有了大概多半年了，快捷键在此记录一下。</li>
</ul>
<h4 id="文件切换"><a href="#文件切换" class="headerlink" title="文件切换"></a>文件切换</h4><p><code>ctrl-shift-s</code> 保存所有打开的文件<br><code>cmd-shift-o</code> 打开目录<br><code>cmd-\</code> 显示或隐藏目录树<br><code>ctrl-0</code> 焦点移到目录树<br>目录树下，使用a，m，delete来增加，修改和删除<br><code>cmd-t</code>或<code>cmd-p</code> 查找文件<br><code>cmd-b</code> 在打开的文件之间切换<br><code>cmd-shift-b</code> 只搜索从上次git commit后修改或者新增的文件</p>
<h4 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h4><p>（等价于上下左右）<br><code>ctrl-p</code> 前一行<br><code>ctrl-n</code> 后一行<br><code>ctrl-f</code> 前一个字符<br><code>ctrl-b</code> 后一个字符<br><code>alt-B, alt-left</code> 移动到单词开始<br><code>alt-F, alt-right</code> 移动到单词末尾<br><code>cmd-right</code>, <code>ctrl-E</code> 移动到一行结束<br><code>cmd-left</code>, <code>ctrl-A</code> 移动到一行开始<br><code>cmd-up</code> 移动到文件开始<br><code>cmd-down</code> 移动到文件结束<br><code>ctrl-g</code> 移动到指定行 row:column 处<br><code>cmd-r</code> 在方法之间跳转</p>
<h4 id="目录树操作"><a href="#目录树操作" class="headerlink" title="目录树操作"></a>目录树操作</h4><p><code>cmd-\\</code> 或者 <code>cmd-k</code> <code>cmd-b</code> 显示(隐藏)目录树<br><code>ctrl-0</code> 焦点切换到目录树(再按一次或者Esc退出目录树)<br><code>a</code> 添加文件<br><code>d</code> 将当前文件另存为(duplicate)<br><code>i</code> 显示(隐藏)版本控制忽略的文件<br><code>alt-right</code> 和 <code>alt-left</code> 展开(隐藏)所有目录<br><code>ctrl-al-]</code> 和 <code>ctrl-al-\[</code> 同上<br><code>ctrl-[</code> 和 <code>ctrl-]</code> 展开(隐藏)当前目录<br><code>ctrl-f</code> 和 <code>ctrl-b</code> 同上<br><code>cmd-k h</code> 或者 <code>cmd-k left</code> 在左半视图中打开文件<br><code>cmd-k j</code> 或者 <code>cmd-k down</code> 在下半视图中打开文件<br><code>cmd-k k</code> 或者 <code>cmd-k up</code> 在上半视图中打开文件<br><code>cmd-k l</code> 或者 <code>cmd-k right</code> 在右半视图中打开文件<br><code>ctrl-shift-C</code> 复制当前文件绝对路径</p>
<h4 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h4><p><code>cmd-F2</code> 在本行增加书签<br><code>F2</code> 跳到当前文件的下一条书签<br><code>shift-F2</code> 跳到当前文件的上一条书签<br><code>ctrl-F2</code> 列出当前工程所有书签</p>
<h4 id="选取"><a href="#选取" class="headerlink" title="选取"></a>选取</h4><ul>
<li>大部分和导航一致，只不过加上shift</li>
</ul>
<p><code>ctrl-shift-P</code> 选取至上一行<br><code>ctrl-shift-N</code> 选取至下一样<br><code>ctrl-shift-B</code> 选取至前一个字符<br><code>ctrl-shift-F</code> 选取至后一个字符<br><code>alt-shift-B</code>, <code>alt-shift-left</code> 选取至字符开始<br><code>alt-shift-F</code>, <code>alt-shift-right</code> 选取至字符结束<br><code>ctrl-shift-E</code>, <code>cmd-shift-right</code> 选取至本行结束<br><code>ctrl-shift-A</code>, <code>cmd-shift-left</code> 选取至本行开始<br><code>cmd-shift-up</code> 选取至文件开始<br><code>cmd-shift-down</code> 选取至文件结尾<br><code>cmd-A</code> 全选<br><code>cmd-L</code> 选取一行，继续按回选取下一行<br><code>ctrl-shift-W</code> 选取当前单词</p>
<h4 id="编辑和删除文本"><a href="#编辑和删除文本" class="headerlink" title="编辑和删除文本"></a>编辑和删除文本</h4><p>基本操作<br><code>ctrl-T</code> 使光标前后字符交换<br><code>cmd-J</code> 将下一行与当前行合并<br><code>ctrl-cmd-up</code>, <code>ctrl-cmd-down</code> 使当前行向上或者向下移动<br><code>cmd-shift-D</code> 复制当前行到下一行<br><code>cmd-K</code>, <code>cmd-U</code>使当前字符大写<br><code>cmd-K</code>, <code>cmd-L</code> 使当前字符小写<br><code>cmd-shift-P</code> 搜索命令</p>
<h4 id="删除和剪切"><a href="#删除和剪切" class="headerlink" title="删除和剪切"></a>删除和剪切</h4><p><code>ctrl-shift-K</code> 删除当前行<br><code>cmd-backspace</code> 删除到当前行开始<br><code>cmd-fn-backspace</code> 删除到当前行结束<br><code>ctrl-K</code> 剪切到当前行结束<br><code>alt-backspace</code> 或 <code>alt-H</code> 删除到当前单词开始<br><code>alt-delete</code> 或 <code>alt-D</code> 删除到当前单词结束</p>
<h4 id="多光标和多处选取"><a href="#多光标和多处选取" class="headerlink" title="多光标和多处选取"></a>多光标和多处选取</h4><p><code>cmd-click</code> 增加新光标<br><code>cmd-shift-L</code> 将多行选取改为多行光标<br><code>ctrl-shift-up</code>, <code>ctrl-shift-down</code> 增加上（下）一行光标<br><code>cmd-D</code> 选取文档中和当前单词相同的下一处<br><code>ctrl-cmd-G</code> 选取文档中所有和当前光标单词相同的位置</p>
<h4 id="括号跳转"><a href="#括号跳转" class="headerlink" title="括号跳转"></a>括号跳转</h4><p><code>ctrl-m</code> 相应括号之间，html tag之间等跳转<br><code>ctrl-cmd-m</code> 括号(tag)之间文本选取<br><code>alt-cmd-.</code> 关闭当前XML/HTML tag</p>
<h4 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h4><p><code>ctrl-shift-U</code> 调出切换编码选项</p>
<h4 id="查找和替换"><a href="#查找和替换" class="headerlink" title="查找和替换"></a>查找和替换</h4><p><code>cmd-F</code> 在buffer中查找<br><code>cmd-shift-f</code> 在整个工程中查找</p>
<h4 id="代码片段"><a href="#代码片段" class="headerlink" title="代码片段"></a>代码片段</h4><p><code>alt-shift-S</code> 查看当前可用代码片段</p>
<p>在~/.atom目录下snippets.cson文件中存放了你定制的snippets定制说明</p>
<h4 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h4><p><code>ctrl-space</code> 提示补全信息</p>
<h4 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h4><p><code>alt-cmd-[</code> 折叠<br><code>alt-cmd-]</code> 展开<br><code>alt-cmd-shift-{</code> 折叠全部<br><code>alt-cmd-shift-}</code> 展开全部<br><code>cmd-k</code> <code>cmd-N</code> 指定折叠层级 N为层级数</p>
<h4 id="文件语法高亮"><a href="#文件语法高亮" class="headerlink" title="文件语法高亮"></a>文件语法高亮</h4><p><code>ctrl-shift-L</code> 选择文本类型</p>
<h4 id="使用Atom进行写作"><a href="#使用Atom进行写作" class="headerlink" title="使用Atom进行写作"></a>使用Atom进行写作</h4><p><code>ctrl-shift-M</code> Markdown预览<br>可用代码片段</p>
<p>b, legal, img, l, i, code, t, table</p>
<h4 id="git操作"><a href="#git操作" class="headerlink" title="git操作"></a>git操作</h4><p><code>cmd-alt-Z</code> checkout HEAD 版本<br><code>cmd-shift-B</code> 弹出untracked 和 modified文件列表<br><code>alt-g</code> down <code>alt-g</code> up 在修改处跳转<br><code>alt-G D</code> 弹出diff列表<br><code>alt-G O</code> 在github上打开文件<br><code>alt-G G</code> 在github上打开项目地址<br><code>alt-G B</code> 在github上打开文件blame<br><code>alt-G H</code> 在github上打开文件history<br><code>alt-G I</code> 在github上打开issues<br><code>alt-G R</code> 在github打开分支比较<br><code>alt-G C</code> 拷贝当前文件在gihub上的网址</p>

          
        
      
    </div>
    
    
    

    

    

    
    <div>

  
</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/排序算法总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="h7lyaphets">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="h7lyaphets">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/排序算法总结/" itemprop="url">排序算法总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T15:11:36+08:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="算法对比分析图"><a href="#算法对比分析图" class="headerlink" title="算法对比分析图"></a>算法对比分析图</h2><p><img src="/2019/04/01/排序算法总结/duibifenxi.png" alt="duibifenxi"></p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。</li>
<li>时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。</li>
<li>空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。</li>
</ul>
<hr>
<h2 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序(Bubble Sort)"></a>冒泡排序(Bubble Sort)</h2><ul>
<li>冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</li>
</ul>
<h3 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h3><ul>
<li>比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>重复步骤1~3，直到排序完成。</li>
</ul>
<h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/2019/04/01/排序算法总结/bubblesort.gif" alt="bubblesort"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="comment">//    冒泡排序</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrTest = &#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">11</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">22</span>,<span class="number">1</span>,<span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c : bubbleSort(arrTest))&#123;</span><br><span class="line">            System.out.println(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println(Arrays.toString(bubbleSort(arrTest)));</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] bubbleSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">boolean</span> swap = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            swap = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; array.length - i - <span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &gt; array[j + <span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = array[j];</span><br><span class="line">                    array[j] = array[j + <span class="number">1</span>];</span><br><span class="line">                    array[j + <span class="number">1</span>] = t;</span><br><span class="line">                    swap = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!swap)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>正好复习一下一维数组的打印方式。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先先定义个一维数组</span></span><br><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种方法。使用传统for循环的方式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;array.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">      System.out.println(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种方式。使用for-each循环的模式</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> a:array)</span><br><span class="line">    System.out.println(a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种方式使用。使用Arrays直接打印出来</span></span><br><span class="line"><span class="comment">// 其中Arrays需要导入import java.util.Arrays;</span></span><br><span class="line">System.out.println(Arrays.toString(array));</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="选择排序算法-Selection-Sort"><a href="#选择排序算法-Selection-Sort" class="headerlink" title="选择排序算法(Selection Sort)"></a>选择排序算法(Selection Sort)</h2><ul>
<li>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>
</ul>
<h3 id="算法描述-1"><a href="#算法描述-1" class="headerlink" title="算法描述"></a>算法描述</h3><p>n个记录的直接选择排序可经过n-1趟直接选择排序得到有序结果。具体算法描述如下：</p>
<ul>
<li>初始状态：无序区为R[1..n]，有序区为空；</li>
<li>第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>n-1趟结束，数组有序化了。</li>
</ul>
<h3 id="动画演示-1"><a href="#动画演示-1" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/2019/04/01/排序算法总结/selectionsort.gif" alt="selectionSort"></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> : hzx</span></span><br><span class="line"><span class="comment">* <span class="doctag">@CreateDate</span> : 2019/4/1 4:04 PM</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> : 选择排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">selectionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrTest = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">1</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : sort(arrTest)) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="keyword">int</span> min;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++) &#123;</span><br><span class="line">            index = i;</span><br><span class="line">            min = array[i];</span><br><span class="line">            <span class="comment">// 找到最小值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] &lt; min) &#123;</span><br><span class="line">                    min = array[j];</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> t = array[i];</span><br><span class="line">            array[i] = array[index];</span><br><span class="line">            array[index] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><ul>
<li>插入排序（Insertion-Sort）的算法描述是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</li>
</ul>
<h3 id="算法描述-2"><a href="#算法描述-2" class="headerlink" title="算法描述"></a>算法描述</h3><p>一般来说，插入排序都采用in-place在数组上实现。具体算法描述如下：</p>
<ul>
<li>从第一个元素开始，该元素可以认为已经被排序；</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>将新元素插入到该位置后；</li>
<li>重复步骤2~5。</li>
</ul>
<h3 id="动画演示-2"><a href="#动画演示-2" class="headerlink" title="动画演示"></a>动画演示</h3><p><img src="/2019/04/01/排序算法总结/insertionsort.gif" alt="insertionsort"></p>
<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Author</span> : hzx</span></span><br><span class="line"><span class="comment">* <span class="doctag">@CreateDate</span> : 2019/4/1 4:18 PM</span></span><br><span class="line"><span class="comment">* <span class="doctag">@Description</span> : 插入排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">insertionSort</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arrTest = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">11</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">22</span>, <span class="number">1</span>, <span class="number">8</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> a : sort(arrTest)) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] sort(<span class="keyword">int</span>[] array)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> key; <span class="comment">// Insert value</span></span><br><span class="line">        <span class="keyword">int</span> preIndex; <span class="comment">// index that need to be move</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; array.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            key = array[i]; <span class="comment">// get the insert value</span></span><br><span class="line">            preIndex = i - <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// move elements which less than key</span></span><br><span class="line">            <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; key &lt; array[preIndex])</span><br><span class="line">            &#123;</span><br><span class="line">                array[preIndex + <span class="number">1</span>] = array[preIndex];</span><br><span class="line">                preIndex--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// put the key in the correct position</span></span><br><span class="line">            array[preIndex + <span class="number">1</span>] = key;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> array;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="明天整理一下"><a href="#明天整理一下" class="headerlink" title="明天整理一下 "></a>明天整理一下 </h2>
          
        
      
    </div>
    
    
    

    

    

    
    <div>

  
</div>
    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">h7lyaphets</p>
              <p class="site-description motion-element" itemprop="description">postgraduate(2017-2020) | CS | java</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">38</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">h7lyaphets</span>

  
</div>


<div class="powered-by">
<i class="fa fa-user-md"></i><span id="busuanzi_container_site_pv">
访客数:<span id="busuanzi_value_site_pv"></span>
</span>
</div>
  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
